package routers

import (
	"net/http"

	"github.com/dehwyy/acheron/apps/stream_x/p2p_establisher/internal/rtc"
	"github.com/dehwyy/acheron/apps/stream_x/p2p_establisher/internal/rtc/whipwhep"
	"github.com/dehwyy/acheron/apps/stream_x/p2p_establisher/internal/server/errors"
	"github.com/dehwyy/acheron/apps/stream_x/p2p_establisher/internal/server/extractors"
	"github.com/dehwyy/acheron/libraries/go/logg"
	"github.com/gin-gonic/gin"
	"github.com/pion/webrtc/v4"
)

const (
	routeHandleWhip = "/whip"
	routeHandleWhep = "/whep"

	ctxOffer = "offer"
	ctxToken = "token"
	ctxConn  = "conn"

	headerXStreamName = "X-Stream-Name"
)

type WhipWhepRouter struct {
	log logg.Logger
	api *rtc.API
}

func (r *WhipWhepRouter) RegisterRoutes(baseRouter *gin.RouterGroup) {
	router := baseRouter.Group("/")
	router.Use(r.prepareConnection())

	router.POST(routeHandleWhip, r.handleWhip)
	router.POST(routeHandleWhep, r.handleWhep)
}

// Middleware
func (r *WhipWhepRouter) prepareConnection() gin.HandlerFunc {
	return func(ctx *gin.Context) {
		offer, err := extractors.BodyToString(ctx.Request.Body)
		if err != nil {
			_ = ctx.AbortWithError(http.StatusInternalServerError, err)
			return
		}

		// TODO: make authorization
		token, err := extractors.GetAuthorizationToken(ctx)
		if err != nil {
			ctx.AbortWithStatusJSON(http.StatusUnauthorized, errors.New(err))
			return
		}

		conn, err := r.api.NewPeerConnection()
		if err != nil {
			ctx.AbortWithStatusJSON(http.StatusInternalServerError, errors.New(err))
			return
		}

		ctx.Set(ctxOffer, offer)
		ctx.Set(ctxToken, token)
		ctx.Set(ctxConn, conn)
		ctx.Next()
	}
}

// @Description Receive **SdpOffer** and **AutorizationToken** from **OBS**. Create *Audio/Video* streams for future broadcoast via `WebRTC`.
// @id HandleWhip
// @Summary *OBS* and *Server* offers exchange.
// @Tags WhipWhep
// @Accept application/sdp
// @Produce application/sdp
// @Param SDPOffer      body   string true "*SDPOffer* generated by **OBS**"
// @Param Authorization header string true "AuthorizationToken set by **OBS**"
// @Success 201 {string} string "ServerSdpAnswer"
// @Header 201 {string} Location "/whip"
// @Failure 401,500 {object} errors.HTTPError
// @Router /whip [post]
func (*WhipWhepRouter) handleWhip(ctx *gin.Context) {
	offer := ctx.GetString(ctxOffer)
	token := ctx.GetString(ctxToken)
	conn := ctx.MustGet(ctxConn).(*webrtc.PeerConnection) // nolint: revive

	// TODO: get `StreamName` from auth
	streamName := token

	sdpAnswer, err := whipwhep.HandleWhipConn(conn, streamName, offer)
	if err != nil {
		ctx.AbortWithStatusJSON(http.StatusInternalServerError, errors.New(err, "Failed to handle WHIP connection!"))
		return
	}

	ctx.Header("Location", "/whip")
	ctx.String(http.StatusCreated, "%s", sdpAnswer)
}

// @Description Receive **SdpOffer** and **AutorizationToken** from **Client**. Retrieve *Audio/Video* streams for future broadcoast via `WebRTC`.
// @id HandleWhep
// @Summary *Client* and *Server* offers excahange.
// @Tags WhipWhep
// @Accept application/sdp
// @Produce application/sdp
// @Param SDPOffer      body   string true "*SDPOffer* generated by **Client**"
// ? @Param Authorization header string true "AuthorizationToken set by **OBS**"
// @Param X-StreamName header string true "Requested *audio+video* stream name"
// @Success 201 {string} string "ServerSdpAnswer"
// @Header 201 {string} Location "/whep"
// @Failure 401,500 {object} errors.HTTPError
// @Router /whep [post]
func (*WhipWhepRouter) handleWhep(ctx *gin.Context) {
	offer := ctx.GetString(ctxOffer)
	// token := ctx.GetString(ctxToken) // TODO: somehow validate user session
	conn := ctx.MustGet(ctxConn).(*webrtc.PeerConnection) // nolint: revive

	streamName := ctx.GetHeader(headerXStreamName)
	sdpAnswer, err := whipwhep.HandleWhepConn(conn, streamName, offer)
	if err != nil {
		ctx.AbortWithStatusJSON(http.StatusInternalServerError, errors.New(err))
		return
	}

	ctx.Header("Location", "/whep")
	ctx.String(http.StatusCreated, "%s", sdpAnswer)
}
